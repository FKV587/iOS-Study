
##### 派发机制

* 值类型总是会使用直接派发, 简单易懂
* 而协议和类的extension都会使用直接派发
* NSObject的extension会使用消息机制进行派发
* NSObject声明作用域里的函数都会使用函数表进行派发
* 协议里声明的, 并且带有默认实现的函数会使用函数表进行派发

##### objc class 里面有那些


##### 在Swift结构体中实现写时复制

* 使用 isKnownUniquelyReferenced 方法检查一个类的实例是不是唯一的引用，如果是，我们就不需要对结构体实例进行复制，如果不是，说明对象被不同的结构体共享，这时对它进行更改就需要进行复制
* 在Swift中采用的优化方式叫做写时复制技术，简单的说就是，只有当一个结构体发生了写入行为时才会有复制行为。具体的做法就是，在结构体内部用一个引用类型来存储实际的数据，在不进行写入操作的普通传递过程中，都是将内部的reference的应用计数+1，在进行写入操作时，对内部的reference做一次copy操作用来存储新的数据，防止和之前的reference产生意外的数据共享。

#####  如何获取当前代码的函数名和行号

* #file 用于获取当前文件文件名
* #line 用于获取当前行号
* #column 用于获取当前列编号
* #function 用于获取当前函数名

##### required
required 是 Swift 中用于类的初始化方法的一个修饰符。它的主要作用是确保子类也必须实现这个初始化方法。这在涉及到协议的初始化方法时尤为重要，因为协议中的初始化方法无法被自动继承。

##### inout

* 使用值类型传递参数，直接修改值类型的值

```
func swap( a: inout Int, b: inout Int) {
    let temp = a
    a = b
    b = temp
}
var a = 1
var b = 2
print(a, b)// 1 2
swap(a: &a, b: &b)
print(a, b)// 2 1
```

##### 下面的代码会不会崩溃，说出原因

```
var mutableArray = [1,2,3]
for _ in mutableArray {
  mutableArray.removeLast()
}
```
在每次迭代时，for-in 循环会遍历最初确定的元素。尽管数组在每次迭代中被修改，但循环依然会按照原始的长度（3 次迭代）进行。这是因为 for-in 在开始时决定了要遍历的元素，而不是在每次迭代时重新计算。

##### some
函数返回值 是协议的时候可以直接使用some关键字标记该协议，译器可以根据返回值进行类型推断得到具体类型，但是不能是多个不同类型否则编译器报错
